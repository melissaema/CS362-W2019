        -:    0:Source:c:/mingw/include/stdio.h
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:3
        -:    0:Programs:3
        -:    1:/*
        -:    2: * stdio.h
        -:    3: *
        -:    4: * Definitions of types and prototypes of functions for operations on
        -:    5: * standard input and standard output streams.
        -:    6: *
        -:    7: * $Id: stdio.h,v 02f7293b615c 2019/01/11 18:01:52 keith $
        -:    8: *
        -:    9: * Written by Colin Peters <colin@bird.fu.is.saga-u.ac.jp>
        -:   10: * Copyright (C) 1997-2005, 2007-2010, 2014-2019, MinGW.org Project.
        -:   11: *
        -:   12: *
        -:   13: * Permission is hereby granted, free of charge, to any person obtaining a
        -:   14: * copy of this software and associated documentation files (the "Software"),
        -:   15: * to deal in the Software without restriction, including without limitation
        -:   16: * the rights to use, copy, modify, merge, publish, distribute, sublicense,
        -:   17: * and/or sell copies of the Software, and to permit persons to whom the
        -:   18: * Software is furnished to do so, subject to the following conditions:
        -:   19: *
        -:   20: * The above copyright notice, this permission notice, and the following
        -:   21: * disclaimer shall be included in all copies or substantial portions of
        -:   22: * the Software.
        -:   23: *
        -:   24: * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        -:   25: * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
        -:   26: * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
        -:   27: * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
        -:   28: * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
        -:   29: * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OF OR OTHER
        -:   30: * DEALINGS IN THE SOFTWARE.
        -:   31: *
        -:   32: * NOTE: The file manipulation functions provided by Microsoft seem to
        -:   33: * work with either slash (/) or backslash (\) as the directory separator;
        -:   34: * (this is consistent with Microsoft's own documentation, on MSDN).
        -:   35: *
        -:   36: */
        -:   37:#ifndef _STDIO_H
        -:   38:#pragma GCC system_header
        -:   39:
        -:   40:/* When including <wchar.h>, some of the definitions and declarations
        -:   41: * which are nominally provided in <stdio.h> must be duplicated.  Rather
        -:   42: * than require duplicated maintenance effort, we provide for partial
        -:   43: * inclusion of <stdio.h> by <wchar.h>; only when not included in
        -:   44: * this partial fashion...
        -:   45: */
        -:   46:#ifndef __WCHAR_H_SOURCED__
        -:   47: /* ...which is exclusive to <wchar.h>, do we assert the multiple
        -:   48:  * inclusion guard for <stdio.h> itself.
        -:   49:  */
        -:   50:#define _STDIO_H
        -:   51:#endif
        -:   52:
        -:   53:/* All the headers include this file.
        -:   54: */
        -:   55:#include <_mingw.h>
        -:   56:
        -:   57:#ifndef RC_INVOKED
        -:   58:/* POSIX stipulates that the following set of types, (as identified by
        -:   59: * __need_TYPENAME macros), shall be defined consistently with <stddef.h>;
        -:   60: * by defining the appropriate __need_TYPENAME macros, we may selectively
        -:   61: * obtain the required definitions by inclusion of <stddef.h>, WITHOUT
        -:   62: * automatic exposure of any of its additional content.
        -:   63: */
        -:   64:#define __need_NULL
        -:   65:#define __need_size_t
        -:   66:#define __need_wchar_t
        -:   67:#define __need_wint_t
        -:   68:#include <stddef.h>
        -:   69:
        -:   70:#if _POSIX_C_SOURCE >= 200809L
        -:   71: /* Similarly, for types defined in <sys/types.h>, (which are explicitly
        -:   72:  * dependent on the POSIX.1-2008 feature test)...
        -:   73:  */
        -:   74:# define __need_off_t
        -:   75:# define __need_ssize_t
        -:   76:#endif
        -:   77:
        -:   78:/* Although non-standard themselves, we also need either one or other
        -:   79: * of the following pair of data types, from <sys/types.h>, because our
        -:   80: * standard fpos_t is opaquely defined in terms of...
        -:   81: */
        -:   82:#ifdef __MSVCRT__
        -:   83: /* ...an explicitly 64-bit file offset type, for MSVCRT.DLL users...
        -:   84:  */
        -:   85:# define __need___off64_t
        -:   86:#else
        -:   87: /* ...or a 32-bit equivalent, for pre-MSVCRT.DLL users.
        -:   88:  */
        -:   89:# define __need___off32_t
        -:   90:#endif
        -:   91:
        -:   92:/* Note the use of the #include "..." form here, to ensure that we get
        -:   93: * the correct header file, relative to the location of this <stdio.h>
        -:   94: */
        -:   95:#include "sys/types.h"
        -:   96:
        -:   97:#ifndef __VALIST
        -:   98: /* Also similarly, for the va_list type, defined in "stdarg.h"
        -:   99:  */
        -:  100:# if defined __GNUC__ && __GNUC__ >= 3
        -:  101:#  define __need___va_list
        -:  102:#  include "stdarg.h"
        -:  103:#  define __VALIST __builtin_va_list
        -:  104:# else
        -:  105:#  define __VALIST char *
        -:  106:# endif
        -:  107:#endif
        -:  108:#endif	/* ! RC_INVOKED */
        -:  109:
        -:  110:#ifdef _STDIO_H
        -:  111:/* Flags for the iobuf structure
        -:  112: */
        -:  113:#define _IOREAD 	1	/* currently reading */
        -:  114:#define _IOWRT		2	/* currently writing */
        -:  115:#define _IORW	   0x0080	/* opened as "r+w" */
        -:  116:
        -:  117:/* The three standard file pointers provided by the run time library.
        -:  118: * NOTE: These will go to the bit-bucket silently in GUI applications!
        -:  119: */
        -:  120:#define STDIN_FILENO	0
        -:  121:#define STDOUT_FILENO	1
        -:  122:#define STDERR_FILENO	2
        -:  123:
        -:  124:/* Returned by various functions on end of file condition or error.
        -:  125: */
        -:  126:#define EOF	      (-1)
        -:  127:
        -:  128:#endif	/* _STDIO_H */
        -:  129:
        -:  130:/* The maximum length of a file name.  It may be better to use the Windows'
        -:  131: * GetVolumeInformation() function in preference to this constant, but hey,
        -:  132: * this works!  Note that <io.h> also defines it, but we don't guard it, so
        -:  133: * that the compiler has a chance to catch inconsistencies.
        -:  134: *
        -:  135: * FIXME: Right now, we define this unconditionally for both full <stdio.h>
        -:  136: * inclusion, and for partial inclusion on behalf of <wchar.h>, (which needs
        -:  137: * it for some non-ANSI structure declarations).  The conditions under which
        -:  138: * <wchar.h> needs this require review, because defining it as a consequence
        -:  139: * of including <wchar.h> alone may violate strict ANSI conformity.
        -:  140: */
        -:  141:#define FILENAME_MAX  (260)
        -:  142:
        -:  143:#ifdef _STDIO_H
        -:  144:/* The maximum number of files that may be open at once. I have set this to
        -:  145: * a conservative number. The actual value may be higher.
        -:  146: */
        -:  147:#define FOPEN_MAX      (20)
        -:  148:
        -:  149:/* After creating this many names, tmpnam and tmpfile return NULL
        -:  150: */
        -:  151:#define TMP_MAX      32767
        -:  152:
        -:  153:/* Tmpnam, tmpfile and, sometimes, _tempnam try to create
        -:  154: * temp files in the root directory of the current drive
        -:  155: * (not in pwd, as suggested by some older MS doc's).
        -:  156: * Redefining these macros does not effect the CRT functions.
        -:  157: */
        -:  158:#define _P_tmpdir   "\\"
        -:  159:#ifndef __STRICT_ANSI__
        -:  160:#define P_tmpdir _P_tmpdir
        -:  161:#endif
        -:  162:#define _wP_tmpdir  L"\\"
        -:  163:
        -:  164:/* The maximum size of name (including NUL) that will be put in the user
        -:  165: * supplied buffer caName for tmpnam.
        -:  166: * Inferred from the size of the static buffer returned by tmpnam
        -:  167: * when passed a NULL argument. May actually be smaller.
        -:  168: */
        -:  169:#define L_tmpnam (16)
        -:  170:
        -:  171:#define _IOFBF		0x0000	/* full buffered */
        -:  172:#define _IOLBF		0x0040	/* line buffered */
        -:  173:#define _IONBF		0x0004	/* not buffered */
        -:  174:
        -:  175:#define _IOMYBUF	0x0008	/* stdio malloc()'d buffer */
        -:  176:#define _IOEOF		0x0010	/* EOF reached on read */
        -:  177:#define _IOERR		0x0020	/* I/O error from system */
        -:  178:#define _IOSTRG 	0x0040	/* Strange or no file descriptor */
        -:  179:#ifdef _POSIX_SOURCE
        -:  180:# define _IOAPPEND	0x0200
        -:  181:#endif
        -:  182:
        -:  183:/* The buffer size as used by setbuf such that it is equivalent to
        -:  184: * (void) setvbuf(fileSetBuffer, caBuffer, _IOFBF, BUFSIZ).
        -:  185: */
        -:  186:#define BUFSIZ		   512
        -:  187:
        -:  188:/* Constants for nOrigin indicating the position relative to which fseek
        -:  189: * sets the file position.  Defined unconditionally since ISO and POSIX
        -:  190: * say they are defined here.
        -:  191: */
        -:  192:#define SEEK_SET	     0
        -:  193:#define SEEK_CUR	     1
        -:  194:#define SEEK_END	     2
        -:  195:
        -:  196:#endif	/* _STDIO_H */
        -:  197:
        -:  198:#ifndef RC_INVOKED
        -:  199:#if ! (defined _STDIO_H && defined _WCHAR_H)
        -:  200:/* The structure underlying the FILE type; this should be defined when
        -:  201: * including either <stdio.h> or <wchar.h>.  If both header include guards
        -:  202: * are now in place, then we must currently be including <stdio.h> in its
        -:  203: * own right, having already processed this block during a prior partial
        -:  204: * inclusion by <wchar.h>; there is no need to process it a second time.
        -:  205: *
        -:  206: * Some believe that nobody in their right mind should make use of the
        -:  207: * internals of this structure. Provided by Pedro A. Aranda Gutiirrez
        -:  208: * <paag@tid.es>.
        -:  209: */
        -:  210:typedef struct _iobuf
        -:  211:{
        -:  212:  char	*_ptr;
        -:  213:  int	 _cnt;
        -:  214:  char	*_base;
        -:  215:  int	 _flag;
        -:  216:  int	 _file;
        -:  217:  int	 _charbuf;
        -:  218:  int	 _bufsiz;
        -:  219:  char	*_tmpfname;
        -:  220:} FILE;
        -:  221:
        -:  222:#endif  /* ! (_STDIO_H && _WCHAR_H) */
        -:  223:#ifdef _STDIO_H
        -:  224:/* Content to be exposed only when including <stdio.h> in its own right;
        -:  225: * these will not be exposed when __WCHAR_H_SOURCE__ is defined, as will
        -:  226: * be the case when <stdio.h> is included indirectly, by <wchar.h>
        -:  227: *
        -:  228: *
        -:  229: * The standard file handles
        -:  230: */
        -:  231:#ifndef __DECLSPEC_SUPPORTED
        -:  232:
        -:  233:extern FILE (*_imp___iob)[];	/* A pointer to an array of FILE */
        -:  234:
        -:  235:#define _iob (*_imp___iob)	/* An array of FILE */
        -:  236:
        -:  237:#else /* __DECLSPEC_SUPPORTED */
        -:  238:
        -:  239:__MINGW_IMPORT FILE _iob[];	/* An array of FILE imported from DLL. */
        -:  240:
        -:  241:#endif /* __DECLSPEC_SUPPORTED */
        -:  242:
        -:  243:#define stdin	(&_iob[STDIN_FILENO])
        -:  244:#define stdout	(&_iob[STDOUT_FILENO])
        -:  245:#define stderr	(&_iob[STDERR_FILENO])
        -:  246:
        -:  247:/* Need to close the current _STDIO_H specific block here...
        -:  248: */
        -:  249:#endif
        -:  250:/* ...because, we need this regardless of the inclusion mode...
        -:  251: */
        -:  252:_BEGIN_C_DECLS
        -:  253:
        -:  254:#ifdef _STDIO_H
        -:  255:/* ...then revert to _STDIO_H specific mode, to declare...
        -:  256: *
        -:  257: *
        -:  258: * File Operations
        -:  259: */
        -:  260:_CRTIMP __cdecl __MINGW_NOTHROW  FILE * fopen (const char *, const char *);
        -:  261:_CRTIMP __cdecl __MINGW_NOTHROW  FILE * freopen (const char *, const char *, FILE *);
        -:  262:_CRTIMP __cdecl __MINGW_NOTHROW  int    fflush (FILE *);
        -:  263:_CRTIMP __cdecl __MINGW_NOTHROW  int    fclose (FILE *);
        -:  264:
        -:  265:/* Note: Microsoft also declares remove & rename (but not their wide char
        -:  266: * variants) in <io.h>; since duplicate prototypes are acceptable, provided
        -:  267: * they are consistent, we simply declare them here anyway, while allowing
        -:  268: * the compiler to check consistency as appropriate.
        -:  269: */
        -:  270:_CRTIMP __cdecl __MINGW_NOTHROW  int    remove (const char *);
        -:  271:_CRTIMP __cdecl __MINGW_NOTHROW  int    rename (const char *, const char *);
        -:  272:_CRTIMP __cdecl __MINGW_NOTHROW  FILE * tmpfile (void);
        -:  273:_CRTIMP __cdecl __MINGW_NOTHROW  char * tmpnam (char *);
        -:  274:
        -:  275:#ifndef __STRICT_ANSI__
        -:  276:_CRTIMP __cdecl __MINGW_NOTHROW  char *_tempnam (const char *, const char *);
        -:  277:_CRTIMP __cdecl __MINGW_NOTHROW  int   _rmtmp (void);
        -:  278:_CRTIMP __cdecl __MINGW_NOTHROW  int   _unlink (const char *);
        -:  279:
        -:  280:#if __MSVCRT_VERSION__>=__MSVCR80_DLL
        -:  281:/* The following pair of non-ANSI functions require a non-free version of
        -:  282: * the Microsoft runtime; neither is provided by any MSVCRT.DLL variant.
        -:  283: */
        -:  284:_CRTIMP __cdecl __MINGW_NOTHROW  void  _lock_file(FILE *);
        -:  285:_CRTIMP __cdecl __MINGW_NOTHROW  void  _unlock_file(FILE *);
        -:  286:#endif
        -:  287:
        -:  288:#ifndef NO_OLDNAMES
        -:  289:_CRTIMP __cdecl __MINGW_NOTHROW  char * tempnam (const char *, const char *);
        -:  290:_CRTIMP __cdecl __MINGW_NOTHROW  int    rmtmp (void);
        -:  291:_CRTIMP __cdecl __MINGW_NOTHROW  int    unlink (const char *);
        -:  292:#endif
        -:  293:#endif /* __STRICT_ANSI__ */
        -:  294:
        -:  295:_CRTIMP __cdecl __MINGW_NOTHROW  int    setvbuf (FILE *, char *, int, size_t);
        -:  296:_CRTIMP __cdecl __MINGW_NOTHROW  void   setbuf (FILE *, char *);
        -:  297:
        -:  298:/* Formatted Output
        -:  299: *
        -:  300: * MSVCRT implementations are not ANSI C99 conformant...
        -:  301: * we offer conforming alternatives from libmingwex.a
        -:  302: */
        -:  303:#undef  __mingw_stdio_redirect__
        -:  304:#define __mingw_stdio_redirect__(F) __cdecl __MINGW_NOTHROW __Wformat(F)
        -:  305:#define __Wformat_mingw_printf(F,A) __attribute__((__format__(__mingw_printf__,F,A)))
        -:  306:
        -:  307:#if __GNUC__ >= 6
        -:  308:/* From GCC-6 onwards, we will provide customized -Wformat
        -:  309: * handling, via our own mingw_printf format category...
        -:  310: */
        -:  311:#define __Wformat(F)		__Wformat_##F __mingw_##F
        -:  312:
        -:  313:#else	/* __GNUC__ < 6 */
        -:  314:/* ...whereas, for earlier GCC, we preserve the status quo,
        -:  315: * offering no -Wformat checking for those functions which
        -:  316: * replace the MSVCRT.DLL versions...
        -:  317: */
        -:  318:#define __Wformat(F)		__mingw_##F
        -:  319:
        -:  320:/* ...while degrading to gnu_printf checking for snprintf()
        -:  321: * and vsnprintf(), (which are ALWAYS MinGW.org variants).
        -:  322: */
        -:  323:#define __mingw_printf__	__gnu_printf__
        -:  324:#endif
        -:  325:
        -:  326:/* The following convenience macros specify the appropriate
        -:  327: * -Wformat checking for MSVCRT.DLL replacement functions...
        -:  328: */
        -:  329:#define __Wformat_printf	__Wformat_mingw_printf(1,2)
        -:  330:#define __Wformat_fprintf	__Wformat_mingw_printf(2,3)
        -:  331:#define __Wformat_sprintf	__Wformat_mingw_printf(2,3)
        -:  332:#define __Wformat_vprintf	__Wformat_mingw_printf(1,0)
        -:  333:#define __Wformat_vfprintf	__Wformat_mingw_printf(2,0)
        -:  334:#define __Wformat_vsprintf	__Wformat_mingw_printf(2,0)
        -:  335:
        -:  336:/* ...while this pair are specific to the two MinGW.org
        -:  337: * only functions.
        -:  338: */
        -:  339:#define __Wformat_snprintf	__Wformat_mingw_printf(3,4)
        -:  340:#define __Wformat_vsnprintf	__Wformat_mingw_printf(3,0)
        -:  341:
        -:  342:extern int __mingw_stdio_redirect__(fprintf)(FILE*, const char*, ...);
        -:  343:extern int __mingw_stdio_redirect__(printf)(const char*, ...);
        -:  344:extern int __mingw_stdio_redirect__(sprintf)(char*, const char*, ...);
        -:  345:extern int __mingw_stdio_redirect__(snprintf)(char*, size_t, const char*, ...);
        -:  346:extern int __mingw_stdio_redirect__(vfprintf)(FILE*, const char*, __VALIST);
        -:  347:extern int __mingw_stdio_redirect__(vprintf)(const char*, __VALIST);
        -:  348:extern int __mingw_stdio_redirect__(vsprintf)(char*, const char*, __VALIST);
        -:  349:extern int __mingw_stdio_redirect__(vsnprintf)(char*, size_t, const char*, __VALIST);
        -:  350:
        -:  351:/* When using these C99 conforming alternatives, we may wish to support
        -:  352: * some of Microsoft's quirky formatting options, even when they violate
        -:  353: * strict C99 conformance.
        -:  354: */
        -:  355:#define _MSVC_PRINTF_QUIRKS		0x0100U
        -:  356:#define _QUERY_MSVC_PRINTF_QUIRKS	~0U, 0U
        -:  357:#define _DISABLE_MSVC_PRINTF_QUIRKS	~_MSVC_PRINTF_QUIRKS, 0U
        -:  358:#define _ENABLE_MSVC_PRINTF_QUIRKS	~0U, _MSVC_PRINTF_QUIRKS
        -:  359:
        -:  360:/* Those quirks which conflict with ANSI C99 specified behaviour are
        -:  361: * disabled by default; use the following function, like this:
        -:  362: *
        -:  363: *   _mingw_output_format_control( _ENABLE_MSVC_PRINTF_QUIRKS );
        -:  364: *
        -:  365: * to enable them, like this:
        -:  366: *
        -:  367: *   state = _mingw_output_format_control( _QUERY_MSVC_PRINTF_QUIRKS )
        -:  368: *		& _MSVC_PRINTF_QUIRKS;
        -:  369: *
        -:  370: * to ascertain the currently active enabled state, or like this:
        -:  371: *
        -:  372: *   _mingw_output_format_control( _DISABLE_MSVC_PRINTF_QUIRKS );
        -:  373: *
        -:  374: * to disable them again.
        -:  375: */
        -:  376:extern unsigned int _mingw_output_format_control( unsigned int, unsigned int );
        -:  377:
        -:  378:#if __USE_MINGW_ANSI_STDIO
        -:  379:/* User has expressed a preference for C99 conformance...
        -:  380: */
        -:  381:# undef __mingw_stdio_redirect__
        -:  382:# ifdef __cplusplus
        -:  383:/* For C++ we use inline implementations, to avoid interference
        -:  384: * with namespace qualification, which may result from using #defines.
        -:  385: */
        -:  386:#  define __mingw_stdio_redirect__  inline __cdecl __MINGW_NOTHROW
        -:  387:
        -:  388:# elif defined __GNUC__
        -:  389:/* FIXME: Is there any GCC version prerequisite here?
        -:  390: *
        -:  391: * We also prefer inline implementations for C, when we can be confident
        -:  392: * that the GNU specific __inline__ mechanism is supported.
        -:  393: */
        -:  394:#  define __mingw_stdio_redirect__  static __inline__ __cdecl __MINGW_NOTHROW
        -:  395:
        -:  396:# else
        -:  397:/* Can't use inlines; fall back on module local static stubs.
        -:  398: */
        -:  399:#  define __mingw_stdio_redirect__  static __cdecl __MINGW_NOTHROW
        -:  400:# endif
        -:  401:
        -:  402:__mingw_stdio_redirect__
        -:  403:int fprintf (FILE *__stream, const char *__format, ...)
        -:  404:{
        -:  405:  register int __retval;
        -:  406:  __builtin_va_list __local_argv; __builtin_va_start( __local_argv, __format );
        -:  407:  __retval = __mingw_vfprintf( __stream, __format, __local_argv );
        -:  408:  __builtin_va_end( __local_argv );
        -:  409:  return __retval;
        -:  410:}
        -:  411:
        -:  412:__mingw_stdio_redirect__
function printf called 0 returned 0% blocks executed 0%
    #####:  413:int printf (const char *__format, ...)
        -:  414:{
        -:  415:  register int __retval;
    #####:  416:  __builtin_va_list __local_argv; __builtin_va_start( __local_argv, __format );
    #####:  417:  __retval = __mingw_vprintf( __format, __local_argv );
call    0 never executed
    #####:  418:  __builtin_va_end( __local_argv );
    #####:  419:  return __retval;
        -:  420:}
        -:  421:
        -:  422:__mingw_stdio_redirect__
        -:  423:int sprintf (char *__stream, const char *__format, ...)
        -:  424:{
        -:  425:  register int __retval;
        -:  426:  __builtin_va_list __local_argv; __builtin_va_start( __local_argv, __format );
        -:  427:  __retval = __mingw_vsprintf( __stream, __format, __local_argv );
        -:  428:  __builtin_va_end( __local_argv );
        -:  429:  return __retval;
        -:  430:}
        -:  431:
        -:  432:__mingw_stdio_redirect__
        -:  433:int vfprintf (FILE *__stream, const char *__format, __VALIST __local_argv)
        -:  434:{
        -:  435:  return __mingw_vfprintf( __stream, __format, __local_argv );
        -:  436:}
        -:  437:
        -:  438:__mingw_stdio_redirect__
        -:  439:int vprintf (const char *__format, __VALIST __local_argv)
        -:  440:{
        -:  441:  return __mingw_vprintf( __format, __local_argv );
        -:  442:}
        -:  443:
        -:  444:__mingw_stdio_redirect__
        -:  445:int vsprintf (char *__stream, const char *__format, __VALIST __local_argv)
        -:  446:{
        -:  447:  return __mingw_vsprintf( __stream, __format, __local_argv );
        -:  448:}
        -:  449:
        -:  450:#else	/* !__USE_MINGW_ANSI_STDIO */
        -:  451:/* Default configuration: simply direct all calls to MSVCRT...
        -:  452: */
        -:  453:_CRTIMP __cdecl __MINGW_NOTHROW  int fprintf (FILE *, const char *, ...);
        -:  454:_CRTIMP __cdecl __MINGW_NOTHROW  int printf (const char *, ...);
        -:  455:_CRTIMP __cdecl __MINGW_NOTHROW  int sprintf (char *, const char *, ...);
        -:  456:_CRTIMP __cdecl __MINGW_NOTHROW  int vfprintf (FILE *, const char *, __VALIST);
        -:  457:_CRTIMP __cdecl __MINGW_NOTHROW  int vprintf (const char *, __VALIST);
        -:  458:_CRTIMP __cdecl __MINGW_NOTHROW  int vsprintf (char *, const char *, __VALIST);
        -:  459:
        -:  460:#endif
        -:  461:/* Regardless of user preference, always offer these alternative
        -:  462: * entry points, for direct access to the MSVCRT implementations,
        -:  463: * with ms_printf -Wformat checking in each case.
        -:  464: */
        -:  465:#undef  __Wformat
        -:  466:#undef  __mingw_stdio_redirect__
        -:  467:#define __mingw_stdio_redirect__(F) __cdecl __MINGW_NOTHROW __Wformat(F)
        -:  468:#define __Wformat_msvcrt_printf(F,A) __attribute__((__format__(__ms_printf__,F,A)))
        -:  469:#define __Wformat(F) __Wformat_ms_##F __msvcrt_##F
        -:  470:
        -:  471:#define __Wformat_ms_printf	__Wformat_msvcrt_printf(1,2)
        -:  472:#define __Wformat_ms_fprintf	__Wformat_msvcrt_printf(2,3)
        -:  473:#define __Wformat_ms_sprintf	__Wformat_msvcrt_printf(2,3)
        -:  474:#define __Wformat_ms_vprintf	__Wformat_msvcrt_printf(1,0)
        -:  475:#define __Wformat_ms_vfprintf	__Wformat_msvcrt_printf(2,0)
        -:  476:#define __Wformat_ms_vsprintf	__Wformat_msvcrt_printf(2,0)
        -:  477:
        -:  478:_CRTIMP int __mingw_stdio_redirect__(fprintf)(FILE *, const char *, ...);
        -:  479:_CRTIMP int __mingw_stdio_redirect__(printf)(const char *, ...);
        -:  480:_CRTIMP int __mingw_stdio_redirect__(sprintf)(char *, const char *, ...);
        -:  481:_CRTIMP int __mingw_stdio_redirect__(vfprintf)(FILE *, const char *, __VALIST);
        -:  482:_CRTIMP int __mingw_stdio_redirect__(vprintf)(const char *, __VALIST);
        -:  483:_CRTIMP int __mingw_stdio_redirect__(vsprintf)(char *, const char *, __VALIST);
        -:  484:
        -:  485:#undef  __mingw_stdio_redirect__
        -:  486:#undef  __Wformat
        -:  487:
        -:  488:/* The following three ALWAYS refer to the MSVCRT implementations...
        -:  489: */
        -:  490:_CRTIMP __cdecl __MINGW_NOTHROW  int _snprintf (char *, size_t, const char *, ...);
        -:  491:_CRTIMP __cdecl __MINGW_NOTHROW  int _vsnprintf (char *, size_t, const char *, __VALIST);
        -:  492:_CRTIMP __cdecl __MINGW_NOTHROW  int _vscprintf (const char *, __VALIST);
        -:  493:
        -:  494:#ifdef _ISOC99_SOURCE
        -:  495:/* Microsoft does not provide implementations for the following,
        -:  496: * which are required by C99.  Note in particular that Microsoft's
        -:  497: * corresponding implementations of _snprintf() and _vsnprintf() are
        -:  498: * NOT compatible with C99, but the following are; if you want the
        -:  499: * MSVCRT behaviour, you MUST use the Microsoft "uglified" names.
        -:  500: */
        -:  501:__cdecl __MINGW_NOTHROW __Wformat_snprintf
        -:  502:int snprintf (char *, size_t, const char *, ...);
        -:  503:
        -:  504:__cdecl __MINGW_NOTHROW __Wformat_vsnprintf
        -:  505:int vsnprintf (char *, size_t, const char *, __VALIST);
        -:  506:
        -:  507:__cdecl __MINGW_NOTHROW
        -:  508:int vscanf (const char * __restrict__, __VALIST);
        -:  509:
        -:  510:__cdecl __MINGW_NOTHROW
        -:  511:int vfscanf (FILE * __restrict__, const char * __restrict__, __VALIST);
        -:  512:
        -:  513:__cdecl __MINGW_NOTHROW
        -:  514:int vsscanf (const char * __restrict__, const char * __restrict__, __VALIST);
        -:  515:
        -:  516:#endif  /* _ISOC99_SOURCE */
        -:  517:#endif	/* <stdio.h> included in its own right */
        -:  518:
        -:  519:#if __MSVCRT_VERSION__ >= __MSVCR80_DLL || _WIN32_WINNT >= _WIN32_WINNT_VISTA
        -:  520:/* In MSVCR80.DLL, (and its descendants), Microsoft introduced variants
        -:  521: * of the printf() functions, with names qualified by an underscore prefix
        -:  522: * and "_p" or "_p_l" suffixes; implemented in Microsoft's typically crass,
        -:  523: * non-standard, and non-portable fashion, these provide support for access
        -:  524: * to printf() arguments in random order, as was standardised by POSIX as a
        -:  525: * feature of the optional Extended Systems Interface (XSI) specification,
        -:  526: * and is now required for conformity with the POSIX.1-2008 base standard.
        -:  527: * Although these additional Microsoft functions were subsequently added
        -:  528: * to MSVCRT.DLL, from Windows-Vista onward, and they are prototyped here,
        -:  529: * MinGW applications are strenuously encouraged to avoid using them; a
        -:  530: * much better alternative is to "#define _XOPEN_SOURCE 700" before any
        -:  531: * system header is included, then use POSIX standard printf() functions
        -:  532: * instead; this is both portable to many non-Windows platforms, and it
        -:  533: * offers better compatibility with earlier Windows versions.
        -:  534: */
        -:  535:#ifndef __have_typedef_locale_t
        -:  536:/* Note that some of the following require the opaque locale_t data type,
        -:  537: * which we may obtain, by selective inclusion, from <locale.h>
        -:  538: */
        -:  539:#define __need_locale_t
        -:  540:#include <locale.h>
        -:  541:#endif
        -:  542:
        -:  543:#ifdef _STDIO_H
        -:  544:/* The following are to be declared only when <stdio.h> is explicitly
        -:  545: * included; the first six are NOT dependent on locale_t...
        -:  546: */
        -:  547:_CRTIMP __cdecl __MINGW_NOTHROW
        -:  548:int _printf_p (const char *, ...);
        -:  549:
        -:  550:_CRTIMP __cdecl __MINGW_NOTHROW
        -:  551:int _fprintf_p (FILE *, const char *, ...);
        -:  552:
        -:  553:_CRTIMP __cdecl __MINGW_NOTHROW
        -:  554:int _sprintf_p (char *, size_t, const char *, ...);
        -:  555:
        -:  556:_CRTIMP __cdecl __MINGW_NOTHROW
        -:  557:int _vprintf_p (const char *, __VALIST);
        -:  558:
        -:  559:_CRTIMP __cdecl __MINGW_NOTHROW
        -:  560:int _vfprintf_p (FILE *, const char *, __VALIST);
        -:  561:
        -:  562:_CRTIMP __cdecl __MINGW_NOTHROW
        -:  563:int _vsprintf_p (char *, size_t, const char *, __VALIST);
        -:  564:
        -:  565:/* ...whereas the following six DO depend on locale_t.
        -:  566: *
        -:  567: * CAVEAT: unless you are linking with non-free MSVCR80.DLL, or one
        -:  568: * of its later derivatives, good luck trying to use these; see the
        -:  569: * explanation in <locale.t>, as to why you may be unable to create,
        -:  570: * or otherwise acquire a reference to, a locale_t object.
        -:  571: */
        -:  572:_CRTIMP __cdecl __MINGW_NOTHROW
        -:  573:int _printf_p_l (const char *, locale_t, ...);
        -:  574:
        -:  575:_CRTIMP __cdecl __MINGW_NOTHROW
        -:  576:int _fprintf_p_l (FILE *, const char *, locale_t, ...);
        -:  577:
        -:  578:_CRTIMP __cdecl __MINGW_NOTHROW
        -:  579:int _sprintf_p_l (char *, size_t, const char *, locale_t, ...);
        -:  580:
        -:  581:_CRTIMP __cdecl __MINGW_NOTHROW
        -:  582:int _vprintf_p_l (const char *, locale_t, __VALIST);
        -:  583:
        -:  584:_CRTIMP __cdecl __MINGW_NOTHROW
        -:  585:int _vfprintf_p_l (FILE *, const char *, locale_t, __VALIST);
        -:  586:
        -:  587:_CRTIMP __cdecl __MINGW_NOTHROW
        -:  588:int _vsprintf_p_l (char *, size_t, const char *, locale_t, __VALIST);
        -:  589:
        -:  590:#endif	/* <stdio.h> included in its own right */
        -:  591:#endif	/* MSVCR80.DLL and descendants, or MSVCRT.DLL since Vista */
        -:  592:
        -:  593:#if ! (defined _STDIO_H && defined _WCHAR_H)
        -:  594:#if __MSVCRT_VERSION__ >= __MSVCR80_DLL || _WIN32_WINNT >= _WIN32_WINNT_VISTA
        -:  595:/* Wide character variants of the foregoing "positional parameter" printf()
        -:  596: * functions; MSDN says that these should be declared when either <stdio.h>, or
        -:  597: * <wchar.h> is included, so we make them selectively available to <wchar.h>,
        -:  598: * but, just as in the foregoing, we advise against their use.
        -:  599: */
        -:  600:_CRTIMP __cdecl __MINGW_NOTHROW
        -:  601:int _wprintf_p (const wchar_t *, ...);
        -:  602:
        -:  603:_CRTIMP __cdecl __MINGW_NOTHROW
        -:  604:int _fwprintf_p (FILE *, const wchar_t *, ...);
        -:  605:
        -:  606:_CRTIMP __cdecl __MINGW_NOTHROW
        -:  607:int _swprintf_p (wchar_t *, size_t, const wchar_t *, ...);
        -:  608:
        -:  609:_CRTIMP __cdecl __MINGW_NOTHROW
        -:  610:int _vwprintf_p (const wchar_t *, __VALIST);
        -:  611:
        -:  612:_CRTIMP __cdecl __MINGW_NOTHROW
        -:  613:int _vfwprintf_p (FILE *, const wchar_t *, __VALIST);
        -:  614:
        -:  615:_CRTIMP __cdecl __MINGW_NOTHROW
        -:  616:int _vswprintf_p (wchar_t *, size_t, const wchar_t *, __VALIST);
        -:  617:
        -:  618:_CRTIMP __cdecl __MINGW_NOTHROW
        -:  619:int _wprintf_p_l (const wchar_t *, locale_t, ...);
        -:  620:
        -:  621:_CRTIMP __cdecl __MINGW_NOTHROW
        -:  622:int _fwprintf_p_l (FILE *, const wchar_t *, locale_t, ...);
        -:  623:
        -:  624:_CRTIMP __cdecl __MINGW_NOTHROW
        -:  625:int _swprintf_p_l (wchar_t *, size_t, const wchar_t *, locale_t, ...);
        -:  626:
        -:  627:_CRTIMP __cdecl __MINGW_NOTHROW
        -:  628:int _vwprintf_p_l (const wchar_t *, locale_t, __VALIST);
        -:  629:
        -:  630:_CRTIMP __cdecl __MINGW_NOTHROW
        -:  631:int _vfwprintf_p_l (FILE *, const wchar_t *, locale_t, __VALIST);
        -:  632:
        -:  633:_CRTIMP __cdecl __MINGW_NOTHROW
        -:  634:int _vswprintf_p_l (wchar_t *, size_t, const wchar_t *, locale_t, __VALIST);
        -:  635:
        -:  636:#endif	/* MSVCR80.DLL and descendants, or MSVCRT.DLL since Vista */
        -:  637:#endif	/* ! (defined _STDIO_H && defined _WCHAR_H) */
        -:  638:#ifdef _STDIO_H
        -:  639:/* Once again, back to <stdio.h> specific declarations.
        -:  640: */
        -:  641:#if _POSIX_C_SOURCE >= 200809L
        -:  642:/* POSIX standard IEEE 1003.1-2008 added getdelim() and getline()
        -:  643: */
        -:  644:__cdecl __MINGW_NOTHROW ssize_t
        -:  645:getdelim (char ** __restrict__, size_t * __restrict__, int, FILE * __restrict__);
        -:  646:
        -:  647:__cdecl __MINGW_NOTHROW ssize_t
        -:  648:getline (char ** __restrict__, size_t * __restrict__, FILE * __restrict__);
        -:  649:
        -:  650:#ifndef __NO_INLINE__
        -:  651:/* getline() is a trivial specialization of getdelim(), which may
        -:  652: * be readily expressed by inline expansion.
        -:  653: */
        -:  654:__CRT_ALIAS __LIBIMPL__(( FUNCTION = getline ))
        -:  655:__cdecl __MINGW_NOTHROW ssize_t getline
        -:  656:( char **__restrict__ __l, size_t *__restrict__ __n, FILE *__restrict__ __s )
        -:  657:{ return getdelim( __l, __n, '\n', __s ); }
        -:  658:
        -:  659:#endif  /* !__NO_INLINE__ */
        -:  660:#endif  /* POSIX.1-2008 */
        -:  661:
        -:  662:/* Formatted Input
        -:  663: */
        -:  664:_CRTIMP __cdecl __MINGW_NOTHROW  int    fscanf (FILE *, const char *, ...);
        -:  665:_CRTIMP __cdecl __MINGW_NOTHROW  int    scanf (const char *, ...);
        -:  666:_CRTIMP __cdecl __MINGW_NOTHROW  int    sscanf (const char *, const char *, ...);
        -:  667:
        -:  668:/* Character Input and Output Functions
        -:  669: */
        -:  670:_CRTIMP __cdecl __MINGW_NOTHROW  int    fgetc (FILE *);
        -:  671:_CRTIMP __cdecl __MINGW_NOTHROW  char * fgets (char *, int, FILE *);
        -:  672:_CRTIMP __cdecl __MINGW_NOTHROW  int    fputc (int, FILE *);
        -:  673:_CRTIMP __cdecl __MINGW_NOTHROW  int    fputs (const char *, FILE *);
        -:  674:_CRTIMP __cdecl __MINGW_NOTHROW  char * gets (char *);
        -:  675:_CRTIMP __cdecl __MINGW_NOTHROW  int    puts (const char *);
        -:  676:_CRTIMP __cdecl __MINGW_NOTHROW  int    ungetc (int, FILE *);
        -:  677:
        -:  678:/* Traditionally, getc and putc are defined as macros. but the
        -:  679: * standard doesn't say that they must be macros.  We use inline
        -:  680: * functions here to allow the fast versions to be used in C++
        -:  681: * with namespace qualification, eg., ::getc.
        -:  682: *
        -:  683: * NOTE: _filbuf and _flsbuf  are not thread-safe.
        -:  684: */
        -:  685:_CRTIMP __cdecl __MINGW_NOTHROW  int   _filbuf (FILE *);
        -:  686:_CRTIMP __cdecl __MINGW_NOTHROW  int   _flsbuf (int, FILE *);
        -:  687:
        -:  688:#if !defined _MT
        -:  689:
        -:  690:__CRT_INLINE __cdecl __MINGW_NOTHROW  int getc (FILE *);
        -:  691:__CRT_INLINE __cdecl __MINGW_NOTHROW  int getc (FILE * __F)
        -:  692:{
        -:  693:  return (--__F->_cnt >= 0)
        -:  694:    ?  (int) (unsigned char) *__F->_ptr++
        -:  695:    : _filbuf (__F);
        -:  696:}
        -:  697:
        -:  698:__CRT_INLINE __cdecl __MINGW_NOTHROW  int putc (int, FILE *);
        -:  699:__CRT_INLINE __cdecl __MINGW_NOTHROW  int putc (int __c, FILE * __F)
        -:  700:{
        -:  701:  return (--__F->_cnt >= 0)
        -:  702:    ?  (int) (unsigned char) (*__F->_ptr++ = (char)__c)
        -:  703:    :  _flsbuf (__c, __F);
        -:  704:}
        -:  705:
        -:  706:__CRT_INLINE __cdecl __MINGW_NOTHROW  int getchar (void);
        -:  707:__CRT_INLINE __cdecl __MINGW_NOTHROW  int getchar (void)
        -:  708:{
        -:  709:  return (--stdin->_cnt >= 0)
        -:  710:    ?  (int) (unsigned char) *stdin->_ptr++
        -:  711:    : _filbuf (stdin);
        -:  712:}
        -:  713:
        -:  714:__CRT_INLINE __cdecl __MINGW_NOTHROW  int putchar(int);
        -:  715:__CRT_INLINE __cdecl __MINGW_NOTHROW  int putchar(int __c)
        -:  716:{
        -:  717:  return (--stdout->_cnt >= 0)
        -:  718:    ?  (int) (unsigned char) (*stdout->_ptr++ = (char)__c)
        -:  719:    :  _flsbuf (__c, stdout);}
        -:  720:
        -:  721:#else  /* Use library functions.  */
        -:  722:
        -:  723:_CRTIMP __cdecl __MINGW_NOTHROW  int    getc (FILE *);
        -:  724:_CRTIMP __cdecl __MINGW_NOTHROW  int    putc (int, FILE *);
        -:  725:_CRTIMP __cdecl __MINGW_NOTHROW  int    getchar (void);
        -:  726:_CRTIMP __cdecl __MINGW_NOTHROW  int    putchar (int);
        -:  727:
        -:  728:#endif
        -:  729:
        -:  730:/* Direct Input and Output Functions
        -:  731: */
        -:  732:_CRTIMP __cdecl __MINGW_NOTHROW  size_t fread (void *, size_t, size_t, FILE *);
        -:  733:_CRTIMP __cdecl __MINGW_NOTHROW  size_t fwrite (const void *, size_t, size_t, FILE *);
        -:  734:
        -:  735:/* File Positioning Functions
        -:  736: */
        -:  737:_CRTIMP __cdecl __MINGW_NOTHROW  int    fseek (FILE *, long, int);
        -:  738:_CRTIMP __cdecl __MINGW_NOTHROW  long   ftell (FILE *);
        -:  739:_CRTIMP __cdecl __MINGW_NOTHROW  void   rewind (FILE *);
        -:  740:
        -:  741:#ifdef __USE_MINGW_FSEEK
        -:  742:/* Workaround for a limitation on Win9x where a file is not zero padded
        -:  743: * on write, following a seek beyond the original end of file; supporting
        -:  744: * redirector functions are implemented in libmingwex.a
        -:  745: *
        -:  746: * Note: this is improper usage.  __USE_MINGW_FSEEK exhibits the form of a
        -:  747: * private (system reserved) feature test macro; as such, users should not
        -:  748: * define it directly, and thus, it really should not have been defined at
        -:  749: * this point; discourage this practice.
        -:  750: */
        -:  751:#warning "The __USE_MINGW_FSEEK feature test is deprecated"
        -:  752:#pragma info "Define _WIN32_WINDOWS, instead of __USE_MINGW_FSEEK"
        -:  753:
        -:  754:#elif _WIN32_WINDOWS >= _WIN32_WINDOWS_95 && _WIN32_WINDOWS < _WIN32_WINNT_WIN2K
        -:  755:/* This is correct usage; the private __USE_MINGW_FSEEK feature affects only
        -:  756: * Win9x, so enable it implicitly when the _WIN32_WINDOWS feature is specified,
        -:  757: * thus indicating the user's intent to target a Win9x platform.
        -:  758: */
        -:  759:#define __USE_MINGW_FSEEK
        -:  760:#endif
        -:  761:
        -:  762:#ifdef __USE_MINGW_FSEEK
        -:  763:/* Regardless of how it may have become defined, when __USE_MINGW_FSEEK has
        -:  764: * been defined, we must redirect calls to fseek() and fwrite(), so that the
        -:  765: * Win9x zero padding limitation can be mitigated.
        -:  766: */
        -:  767:__cdecl __MINGW_NOTHROW  int __mingw_fseek (FILE *, __off64_t, int);
        -:  768:__CRT_ALIAS int fseek( FILE *__fp, long __offset, int __whence )
        -:  769:{ return __mingw_fseek( __fp, (__off64_t)(__offset), __whence ); }
        -:  770:
        -:  771:__cdecl __MINGW_NOTHROW  size_t __mingw_fwrite (const void *, size_t, size_t, FILE *);
        -:  772:__CRT_ALIAS size_t fwrite( const void *__buf, size_t __len, size_t __cnt, FILE *__fp )
        -:  773:{ return __mingw_fwrite( __buf, __len, __cnt, __fp ); }
        -:  774:#endif /* __USE_MINGW_FSEEK */
        -:  775:
        -:  776:/* An opaque data type used for storing file positions...  The contents
        -:  777: * of this type are unknown, but we (the compiler) need to know the size
        -:  778: * because the programmer using fgetpos and fsetpos will be setting aside
        -:  779: * storage for fpos_t aggregates.  Actually I tested using a byte array and
        -:  780: * it is fairly evident that fpos_t is a 32-bit type in CRTDLL.DLL, but in
        -:  781: * MSVCRT.DLL, it is a 64-bit type.  Define it in terms of an int type of
        -:  782: * the appropriate size, encapsulated within an aggregate type, to make
        -:  783: * it opaque to casting, and so discourage abuse.
        -:  784: */
        -:  785:#ifdef __MSVCRT__
        -:  786:typedef union { __int64 __value; __off64_t __offset; } fpos_t;
        -:  787:#else
        -:  788:typedef union { __int32 __value; __off32_t __offset; } fpos_t;
        -:  789:#endif
        -:  790:
        -:  791:_CRTIMP __cdecl __MINGW_NOTHROW  int fgetpos (FILE *, fpos_t *);
        -:  792:_CRTIMP __cdecl __MINGW_NOTHROW  int fsetpos (FILE *, const fpos_t *);
        -:  793:
        -:  794:#if _WIN32_WINNT >= _WIN32_WINNT_VISTA || __MSVCRT_VERSION__ >= __MSVCR80_DLL
        -:  795: /* Microsoft introduced a number of variations on fseek() and ftell(),
        -:  796:  * beginning with MSVCR80.DLL; the bare _fseeki64() and _ftelli64() were
        -:  797:  * subsequently integrated into MSVCRT.DLL, from Vista onward...
        -:  798:  */
        -:  799:_CRTIMP __cdecl __MINGW_NOTHROW  int    _fseeki64 (FILE *, __int64, int);
        -:  800:_CRTIMP __cdecl __MINGW_NOTHROW __int64 _ftelli64 (FILE *);
        -:  801:
        -:  802:#if __MSVCRT_VERSION__ >= __MSVCR80_DLL
        -:  803: /* ...while the "nolock" variants remain exclusive to MSVCR80.DLL, and
        -:  804:  * its later MSVC specific derivatives.
        -:  805:  */
        -:  806:_CRTIMP __cdecl __MINGW_NOTHROW  int    _fseek_nolock (FILE *, long, int);
        -:  807:_CRTIMP __cdecl __MINGW_NOTHROW  long   _ftell_nolock (FILE *);
        -:  808:
        -:  809:_CRTIMP __cdecl __MINGW_NOTHROW  int    _fseeki64_nolock (FILE *, __int64, int);
        -:  810:_CRTIMP __cdecl __MINGW_NOTHROW __int64 _ftelli64_nolock (FILE *);
        -:  811:
        -:  812:#endif  /* MSVCR80.DLL and later derivatives ONLY */
        -:  813:
        -:  814:#else	/* pre-MSVCR80.DLL or MSVCRT.DLL pre-Vista */
        -:  815:/* The Microsoft DLLs don't provide either _fseeki64() or _ftelli64(), but
        -:  816: * they DO provide fgetpos(), fsetpos(), and _lseeki64(), which may be used
        -:  817: * to emulate the two missing functions.  (Note that we choose to provide
        -:  818: * these emulations in the form of MinGW external helper functions, rather
        -:  819: * than pollute the <stdio.h> namespace with declarations, such as that
        -:  820: * for _lseeki64(), which properly belongs in <io.h>).
        -:  821: */
        -:  822:#ifndef __USE_MINGW_FSEEK
        -:  823:/* If this option has been selected, an alternative emulation for _fseeki64()
        -:  824: * is provided later, to ensure that the call is wrapped in a MinGW specific
        -:  825: * fseek() handling API.
        -:  826: */
        -:  827:int __cdecl __MINGW_NOTHROW __mingw_fseeki64 (FILE *, __int64, int);
        -:  828:__CRT_ALIAS __cdecl __MINGW_NOTHROW  int _fseeki64 (FILE *__f, __int64 __o, int __w)
        -:  829:{ return __mingw_fseeki64 (__f, __o, __w); }
        -:  830:#endif
        -:  831:
        -:  832:__int64 __cdecl __MINGW_NOTHROW __mingw_ftelli64 (FILE *);
        -:  833:__CRT_ALIAS __cdecl  __int64 __MINGW_NOTHROW _ftelli64 (FILE *__file )
        -:  834:{ return __mingw_ftelli64 (__file); }
        -:  835:
        -:  836:#endif	/* pre-MSVCR80.DLL or MSVCRT.DLL pre-Vista */
        -:  837:
        -:  838:/* Error Functions
        -:  839: */
        -:  840:_CRTIMP __cdecl __MINGW_NOTHROW  int feof (FILE *);
        -:  841:_CRTIMP __cdecl __MINGW_NOTHROW  int ferror (FILE *);
        -:  842:
        -:  843:#ifdef __cplusplus
        -:  844:inline __cdecl __MINGW_NOTHROW  int feof (FILE * __F){ return __F->_flag & _IOEOF; }
        -:  845:inline __cdecl __MINGW_NOTHROW  int ferror (FILE * __F){ return __F->_flag & _IOERR; }
        -:  846:#else
        -:  847:#define feof(__F)     ((__F)->_flag & _IOEOF)
        -:  848:#define ferror(__F)   ((__F)->_flag & _IOERR)
        -:  849:#endif
        -:  850:
        -:  851:_CRTIMP __cdecl __MINGW_NOTHROW  void clearerr (FILE *);
        -:  852:_CRTIMP __cdecl __MINGW_NOTHROW  void perror (const char *);
        -:  853:
        -:  854:#ifndef __STRICT_ANSI__
        -:  855:/*
        -:  856: * Pipes
        -:  857: */
        -:  858:_CRTIMP __cdecl __MINGW_NOTHROW  FILE * _popen (const char *, const char *);
        -:  859:_CRTIMP __cdecl __MINGW_NOTHROW  int    _pclose (FILE *);
        -:  860:
        -:  861:#ifndef NO_OLDNAMES
        -:  862:_CRTIMP __cdecl __MINGW_NOTHROW  FILE *  popen (const char *, const char *);
        -:  863:_CRTIMP __cdecl __MINGW_NOTHROW  int     pclose (FILE *);
        -:  864:#endif
        -:  865:
        -:  866:/* Other Non ANSI functions
        -:  867: */
        -:  868:_CRTIMP __cdecl __MINGW_NOTHROW  int    _flushall (void);
        -:  869:_CRTIMP __cdecl __MINGW_NOTHROW  int    _fgetchar (void);
        -:  870:_CRTIMP __cdecl __MINGW_NOTHROW  int    _fputchar (int);
        -:  871:_CRTIMP __cdecl __MINGW_NOTHROW  FILE * _fdopen (int, const char *);
        -:  872:_CRTIMP __cdecl __MINGW_NOTHROW  int    _fileno (FILE *);
        -:  873:_CRTIMP __cdecl __MINGW_NOTHROW  int    _fcloseall (void);
        -:  874:_CRTIMP __cdecl __MINGW_NOTHROW  FILE * _fsopen (const char *, const char *, int);
        -:  875:#ifdef __MSVCRT__
        -:  876:_CRTIMP __cdecl __MINGW_NOTHROW  int    _getmaxstdio (void);
        -:  877:_CRTIMP __cdecl __MINGW_NOTHROW  int    _setmaxstdio (int);
        -:  878:#endif
        -:  879:
        -:  880:/* Microsoft introduced a capability in MSVCR80.DLL and later, to
        -:  881: * set the minimum number of digits to be displayed in a printf()
        -:  882: * floating point exponent; they retro-fitted this in MSVCRT.DLL,
        -:  883: * from Windows-Vista onwards, but we provide our own wrappers in
        -:  884: * libmingwex.a, which make it possible for us to emulate the API
        -:  885: * for any version of MSVCRT.DLL (including WinXP and earlier).
        -:  886: */
        -:  887:#define _TWO_DIGIT_EXPONENT    1
        -:  888:
        -:  889:/* While Microsoft define the preceding manifest constant, they
        -:  890: * appear to neglect to define its complement, (for restoration
        -:  891: * of their default exponent display format); for orthogonality,
        -:  892: * we will provide this regardless of Microsoft's negligence.
        -:  893: */
        -:  894:#define _THREE_DIGIT_EXPONENT  0
        -:  895:
        -:  896:/* Once again, unspecified by Microsoft, (and mostly redundant),
        -:  897: * it is convenient to specify a combining mask for these.
        -:  898: */
        -:  899:#define _EXPONENT_DIGIT_MASK  (_TWO_DIGIT_EXPONENT | _THREE_DIGIT_EXPONENT)
        -:  900:
        -:  901:unsigned int __cdecl __mingw_get_output_format (void);
        -:  902:unsigned int __cdecl __mingw_set_output_format (unsigned int);
        -:  903:
        -:  904:/* Also appearing for the first time in MSVCR80.DLL, and then also
        -:  905: * retro-fitted to MSVCRT.DLL from Windows-Vista onwards, was this
        -:  906: * pair of functions to control availability of "%n" formatting in
        -:  907: * the MSVCRT.DLL printf() family of functions, for which we also
        -:  908: * provide our own DLL version agnostic wrappers:
        -:  909: */
        -:  910:int __cdecl __mingw_get_printf_count_output (void);
        -:  911:int __cdecl __mingw_set_printf_count_output (int);
        -:  912:
        -:  913:#if __MSVCRT_VERSION__ >= __MSVCR80_DLL
        -:  914:/* When the user declares that MSVCR80.DLL features are supported,
        -:  915: * we simply expose the corresponding APIs...
        -:  916: */
        -:  917:_CRTIMP unsigned int __cdecl __MINGW_NOTHROW _get_output_format (void);
        -:  918:_CRTIMP unsigned int __cdecl __MINGW_NOTHROW _set_output_format (unsigned int);
        -:  919:
        -:  920:_CRTIMP __cdecl __MINGW_NOTHROW  int _get_printf_count_output (void);
        -:  921:_CRTIMP __cdecl __MINGW_NOTHROW  int _set_printf_count_output (int);
        -:  922:
        -:  923:#else
        -:  924:/* ...otherwise, we emulate the APIs, in a DLL version agnostic
        -:  925: * manner, using our own implementation wrappers.
        -:  926: */
        -:  927:__CRT_ALIAS unsigned int __cdecl _get_output_format (void)
        -:  928:{ return __mingw_get_output_format (); }
        -:  929:
        -:  930:__CRT_ALIAS unsigned int __cdecl _set_output_format (unsigned int __style)
        -:  931:{ return __mingw_set_output_format (__style); }
        -:  932:
        -:  933:/* When using our own printf() implementation, "%n" format is ALWAYS
        -:  934: * supported, so we make this API a no-op, reporting it to be so; for
        -:  935: * the alternative case, when using MSVCRT.DLL's printf(), we delegate
        -:  936: * to our wrapper API implementation, which will invoke the API function
        -:  937: * calls within the DLL, if they are available, or persistently report
        -:  938: * the state of "%n" formatting as DISABLED if they are not.
        -:  939: */
        -:  940:#if __USE_MINGW_ANSI_STDIO
        -:  941:/* Note that __USE_MINGW_ANSI_STDIO is not guaranteed to resolve to any
        -:  942: * symbol which will represent a compilable logic state; map it to this
        -:  943: * alternative which will, for the true state...
        -:  944: */
        -:  945:# define __USE_MINGW_PRINTF  1
        -:  946:#else
        -:  947:/* ...and for the false.
        -:  948: */
        -:  949:# define __USE_MINGW_PRINTF  0
        -:  950:#endif
        -:  951:
        -:  952:__CRT_ALIAS int __cdecl _get_printf_count_output (void)
        -:  953:{ return __USE_MINGW_PRINTF ? 1 : __mingw_get_printf_count_output (); }
        -:  954:
        -:  955:__CRT_ALIAS int __cdecl _set_printf_count_output (int __mode)
        -:  956:{ return __USE_MINGW_PRINTF ? 1 : __mingw_set_printf_count_output (__mode); }
        -:  957:#endif
        -:  958:
        -:  959:#ifndef _NO_OLDNAMES
        -:  960:_CRTIMP __cdecl __MINGW_NOTHROW  int    fgetchar (void);
        -:  961:_CRTIMP __cdecl __MINGW_NOTHROW  int    fputchar (int);
        -:  962:_CRTIMP __cdecl __MINGW_NOTHROW  FILE * fdopen (int, const char *);
        -:  963:_CRTIMP __cdecl __MINGW_NOTHROW  int    fileno (FILE *);
        -:  964:#endif	/* !_NO_OLDNAMES */
        -:  965:
        -:  966:#define _fileno(__F) ((__F)->_file)
        -:  967:#ifndef _NO_OLDNAMES
        -:  968:#define fileno(__F) ((__F)->_file)
        -:  969:#endif
        -:  970:
        -:  971:#if defined (__MSVCRT__) && ! defined (__NO_MINGW_LFS)
        -:  972:__CRT_ALIAS FILE * __cdecl __MINGW_NOTHROW  fopen64 (const char *, const char *);
        -:  973:__CRT_ALIAS __JMPSTUB__(( FUNCTION = fopen64, REMAPPED = fopen ))
        -:  974:FILE * __cdecl __MINGW_NOTHROW  fopen64 (const char * filename, const char * mode)
        -:  975:{ return fopen (filename, mode); }
        -:  976:
        -:  977:int __cdecl __MINGW_NOTHROW  fseeko64 (FILE *, __off64_t, int);
        -:  978:
        -:  979:#ifdef __USE_MINGW_FSEEK
        -:  980:/* When this option is selected, we need to redirect calls to _fseeki64()
        -:  981: * and fseeko64() through a MinGW specific wrapper.  Since the two functions
        -:  982: * are fundamentally identical, differing only in the type of the "offset"
        -:  983: * argument, (and both types are effectively 64-bit signed ints anyway),
        -:  984: * the same wrapper will suffice for both.
        -:  985: */
        -:  986:__CRT_ALIAS int _fseeki64( FILE *__fp, __int64 __offset, int __whence )
        -:  987:{ return __mingw_fseek( __fp, (__off64_t)(__offset), __whence ); }
        -:  988:
        -:  989:__CRT_ALIAS int fseeko64( FILE *__fp, __off64_t __offset, int __whence )
        -:  990:{ return __mingw_fseek( __fp, __offset, __whence ); }
        -:  991:#endif
        -:  992:
        -:  993:__off64_t __cdecl __MINGW_NOTHROW ftello64 (FILE *);
        -:  994:
        -:  995:#endif	/* __MSVCRT__ && !__NO_MINGW_LFS */
        -:  996:#endif	/* !__STRICT_ANSI__ */
        -:  997:#endif	/* _STDIO_H */
        -:  998:
        -:  999:#if ! (defined _STDIO_H && defined _WCHAR_H)
        -: 1000:/* The following are declared when including either <stdio.h> or <wchar.h>.
        -: 1001: * If both header include guards are now in place, then we must currently be
        -: 1002: * including <stdio.h> in its own right, having already processed this block
        -: 1003: * during prior partial inclusion by <wchar.h>; there is no need to process
        -: 1004: * it a second time.
        -: 1005: */
        -: 1006:_CRTIMP __cdecl __MINGW_NOTHROW  int     fwprintf (FILE *, const wchar_t *, ...);
        -: 1007:_CRTIMP __cdecl __MINGW_NOTHROW  int     wprintf (const wchar_t *, ...);
        -: 1008:_CRTIMP __cdecl __MINGW_NOTHROW  int     vfwprintf (FILE *, const wchar_t *, __VALIST);
        -: 1009:_CRTIMP __cdecl __MINGW_NOTHROW  int     vwprintf (const wchar_t *, __VALIST);
        -: 1010:_CRTIMP __cdecl __MINGW_NOTHROW  int    _snwprintf (wchar_t *, size_t, const wchar_t *, ...);
        -: 1011:_CRTIMP __cdecl __MINGW_NOTHROW  int    _vscwprintf (const wchar_t *, __VALIST);
        -: 1012:_CRTIMP __cdecl __MINGW_NOTHROW  int    _vsnwprintf (wchar_t *, size_t, const wchar_t *, __VALIST);
        -: 1013:_CRTIMP __cdecl __MINGW_NOTHROW  int     fwscanf (FILE *, const wchar_t *, ...);
        -: 1014:_CRTIMP __cdecl __MINGW_NOTHROW  int     wscanf (const wchar_t *, ...);
        -: 1015:_CRTIMP __cdecl __MINGW_NOTHROW  int     swscanf (const wchar_t *, const wchar_t *, ...);
        -: 1016:_CRTIMP __cdecl __MINGW_NOTHROW  wint_t  fgetwc (FILE *);
        -: 1017:_CRTIMP __cdecl __MINGW_NOTHROW  wint_t  fputwc (wchar_t, FILE *);
        -: 1018:_CRTIMP __cdecl __MINGW_NOTHROW  wint_t  ungetwc (wchar_t, FILE *);
        -: 1019:
        -: 1020:#ifndef __STRICT_ANSI__
        -: 1021:/* These differ from the ISO C prototypes, which have a maxlen parameter (like snprintf).
        -: 1022: */
        -: 1023:_CRTIMP __cdecl __MINGW_NOTHROW  int  swprintf (wchar_t *, const wchar_t *, ...);
        -: 1024:_CRTIMP __cdecl __MINGW_NOTHROW  int  vswprintf (wchar_t *, const wchar_t *, __VALIST);
        -: 1025:#endif
        -: 1026:
        -: 1027:#ifdef __MSVCRT__
        -: 1028:_CRTIMP __cdecl __MINGW_NOTHROW  wchar_t * fgetws (wchar_t *, int, FILE *);
        -: 1029:_CRTIMP __cdecl __MINGW_NOTHROW  int       fputws (const wchar_t *, FILE *);
        -: 1030:_CRTIMP __cdecl __MINGW_NOTHROW  wint_t    getwc (FILE *);
        -: 1031:_CRTIMP __cdecl __MINGW_NOTHROW  wint_t    getwchar (void);
        -: 1032:_CRTIMP __cdecl __MINGW_NOTHROW  wint_t    putwc (wint_t, FILE *);
        -: 1033:_CRTIMP __cdecl __MINGW_NOTHROW  wint_t    putwchar (wint_t);
        -: 1034:
        -: 1035:#ifndef __STRICT_ANSI__
        -: 1036:_CRTIMP __cdecl __MINGW_NOTHROW  wchar_t * _getws (wchar_t *);
        -: 1037:_CRTIMP __cdecl __MINGW_NOTHROW  int       _putws (const wchar_t *);
        -: 1038:_CRTIMP __cdecl __MINGW_NOTHROW  FILE    * _wfdopen(int, const wchar_t *);
        -: 1039:_CRTIMP __cdecl __MINGW_NOTHROW  FILE    * _wfopen (const wchar_t *, const wchar_t *);
        -: 1040:_CRTIMP __cdecl __MINGW_NOTHROW  FILE    * _wfreopen (const wchar_t *, const wchar_t *, FILE *);
        -: 1041:_CRTIMP __cdecl __MINGW_NOTHROW  FILE    * _wfsopen (const wchar_t *, const wchar_t *, int);
        -: 1042:_CRTIMP __cdecl __MINGW_NOTHROW  wchar_t * _wtmpnam (wchar_t *);
        -: 1043:_CRTIMP __cdecl __MINGW_NOTHROW  wchar_t * _wtempnam (const wchar_t *, const wchar_t *);
        -: 1044:_CRTIMP __cdecl __MINGW_NOTHROW  int       _wrename (const wchar_t *, const wchar_t *);
        -: 1045:_CRTIMP __cdecl __MINGW_NOTHROW  int       _wremove (const wchar_t *);
        -: 1046:_CRTIMP __cdecl __MINGW_NOTHROW  void      _wperror (const wchar_t *);
        -: 1047:_CRTIMP __cdecl __MINGW_NOTHROW  FILE    * _wpopen (const wchar_t *, const wchar_t *);
        -: 1048:
        -: 1049:#endif  /* !__STRICT_ANSI__ */
        -: 1050:#endif	/* __MSVCRT__ */
        -: 1051:
        -: 1052:#ifdef _ISOC99_SOURCE
        -: 1053:__JMPSTUB__(( FUNCTION = snwprintf, DLLENTRY = _snwprintf ))
        -: 1054:__cdecl __MINGW_NOTHROW  int snwprintf (wchar_t *, size_t, const wchar_t *, ...);
        -: 1055:__cdecl __MINGW_NOTHROW  int vsnwprintf (wchar_t *, size_t, const wchar_t *, __VALIST);
        -: 1056:
        -: 1057:#ifndef __NO_INLINE__
        -: 1058:__CRT_INLINE __cdecl __MINGW_NOTHROW
        -: 1059:__JMPSTUB__(( FUNCTION = vsnwprintf, DLLENTRY = _vsnwprintf ))
        -: 1060:int vsnwprintf (wchar_t *__s, size_t __n, const wchar_t *__fmt, __VALIST __arg)
        -: 1061:{ return _vsnwprintf ( __s, __n, __fmt, __arg); }
        -: 1062:#endif
        -: 1063:
        -: 1064:__cdecl __MINGW_NOTHROW  int  vwscanf (const wchar_t *__restrict__, __VALIST);
        -: 1065:__cdecl __MINGW_NOTHROW
        -: 1066:int  vfwscanf (FILE *__restrict__, const wchar_t *__restrict__, __VALIST);
        -: 1067:__cdecl __MINGW_NOTHROW
        -: 1068:int  vswscanf (const wchar_t *__restrict__, const wchar_t * __restrict__, __VALIST);
        -: 1069:
        -: 1070:#endif  /* _ISOC99_SOURCE */
        -: 1071:#endif  /* ! (_STDIO_H && _WCHAR_H) */
        -: 1072:
        -: 1073:#if defined _STDIO_H && ! defined __STRICT_ANSI__
        -: 1074:#if defined __MSVCRT__ && ! defined _NO_OLDNAMES
        -: 1075:_CRTIMP __cdecl __MINGW_NOTHROW  FILE * wpopen (const wchar_t *, const wchar_t *);
        -: 1076:#endif
        -: 1077:
        -: 1078:/* Other non-ANSI wide character functions...
        -: 1079: */
        -: 1080:_CRTIMP __cdecl __MINGW_NOTHROW  wint_t _fgetwchar (void);
        -: 1081:_CRTIMP __cdecl __MINGW_NOTHROW  wint_t _fputwchar (wint_t);
        -: 1082:_CRTIMP __cdecl __MINGW_NOTHROW  int    _getw (FILE *);
        -: 1083:_CRTIMP __cdecl __MINGW_NOTHROW  int    _putw (int, FILE *);
        -: 1084:
        -: 1085:#ifndef _NO_OLDNAMES
        -: 1086:/* ...and their original names, before Microsoft uglification...
        -: 1087: */
        -: 1088:_CRTIMP __cdecl __MINGW_NOTHROW  wint_t  fgetwchar (void);
        -: 1089:_CRTIMP __cdecl __MINGW_NOTHROW  wint_t  fputwchar (wint_t);
        -: 1090:_CRTIMP __cdecl __MINGW_NOTHROW  int     getw (FILE *);
        -: 1091:_CRTIMP __cdecl __MINGW_NOTHROW  int     putw (int, FILE *);
        -: 1092:
        -: 1093:#endif  /* !_NO_OLDNAMES */
        -: 1094:#endif  /* !__STRICT_ANSI__ */
        -: 1095:
        -: 1096:_END_C_DECLS
        -: 1097:
        -: 1098:#endif	/* ! RC_INVOKED */
        -: 1099:#endif  /* !_STDIO_H: $RCSfile: stdio.h,v $: end of file */
